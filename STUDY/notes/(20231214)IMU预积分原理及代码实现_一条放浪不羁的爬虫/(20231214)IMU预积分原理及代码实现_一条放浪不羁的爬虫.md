# IMU预积分原理及代码实现

 **Author:** [一条放浪不羁的爬虫]

 **Link:** [https://zhuanlan.zhihu.com/p/338919099]

### 1. IMU测量模型  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-6129548be45cda3b885f3240fb5217b2_1440w.jpg)  


IMU测量模型

  
  
### 2.相邻两个IMU数据之间的积分递推，时间间隔\Delta t恒定  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-cda01f9216cc732c383281dbcdb2a750_1440w.jpg)  


相邻两个imu数据之间的递推

  
  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-fe3a746d4039362a60a66332143ea59c_1440w.jpg)  


IMU 预积分示意图

  
  
### 3. 从i时刻积分到j时刻的递推公式，中间包含很多个IMU数据，每个IMU数据之间的时间间隔都是\Delta t  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-1738e994abc44092416e22ee1afac7f6_1440w.jpg)  


动力学积分递推公式

  
  
### 4. 写成预积分形式，使得预积分量不和i时刻和j时刻的状态量相关，这样每次更新i时刻和j时刻的状态量时就不需要重新计算预积分量  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-c2b75f85d31a404a566a9e5c0a017f2a_1440w.jpg)  


预积分原始公式

  
  
前两个预积分项显而易见，推导第三个位置的变换，我们记 $\xi = (\tilde a_k - b_k^a - \eta_k^{ad})$ ，

$\Delta t_{ij} = (j-i)\Delta t = \sum_{k=i}^{j}{\Delta t}$ 

$\frac{j-i}{2}-\frac{(j-i)^2}{2}=- \frac{(j-i)(j-(i+1))}{2}=-\sum_{k=i}^{j-1}{(k-i)}$ 

$\begin{aligned} \Delta p_{ij} &= R_i^T(p_j-p_i-v_i\Delta{t_{ij}}-\frac{1}{2}g\Delta{t_{ij}^2})\\                    &=R_i^T(\sum_{k=i}^{j-1}{(v_k\Delta t+\frac{1}{2}g\Delta{t_{}^2}+\frac{1}{2}R_k\xi\Delta t^2)}-v_i\Delta{t_{ij}}-\frac{1}{2}g\Delta{t_{ij}^2})\\                    &= R_i^T(\sum_{k=i}^{j-1}{(v_k\Delta t+\frac{1}{2}R_k\xi\Delta t^2)}-\sum_{k=i}^{j-1}v_i\Delta{t}+\frac{(j-i)}{2}g\Delta{t^2}-\frac{(j-i)^2}{2}g\Delta{t^2})\\ &=R_i^T(\sum_{k=i}^{j-1}{(v_k\Delta t - v_i\Delta t+\frac{1}{2}R_k\xi\Delta t^2)}-\sum_{k=i}^{j}{\Delta t_{ik}g\Delta t})\\ &= R_i^T(\sum_{k=i}^{j-1}{(v_k- v_i-g\Delta t_{ik})\Delta t+\frac{1}{2}R_k\xi\Delta t^2)})\\ &= R_i^T(\sum_{k=i}^{j-1}({R_i\Delta v_{ik}\Delta t+\frac{1}{2}R_k\xi\Delta t^2)})\\ &= \sum_{k=i}^{j-1}({\Delta v_{ik}\Delta t+\frac{1}{2}\Delta {R_{ik}}\xi\Delta t^2)}\\ \end{aligned}$ 

我们设预积分起始IMU时刻记为 $i$ ，终点IMU时刻记为 $j$ ，如上图IMU预积分示意图所示， $i<=k<=j-1$ 表示中间某一个时刻，假设我们已知 $k-1$ 时刻的预积分项，现在需要通过递推来计算 $k$ 时刻的预积分项。(注：我们不能直接通过上式一步计算出预积分项，因为 $\Delta v $ 中含有 $\Delta R_{ik}$ 项，$\Delta p$ 中含有 $\Delta R_{ik}$ 和 $\Delta v_{ik}$ 项，，因此必须一步一步递推计算)。

于是将预积分项 $\Delta v$ 写成递推形式有：


> $a_k=\tilde a_k - b_a^k,\omega_k=\tilde \omega_k-b_g^k$   
> $dt_{k} = dt_{k-1}+\Delta t$   
> $dp_{k}=dp_{k-1}+dv_{k-1}*\Delta t + \frac{1}{2}dq_{k-1}*a_k*\Delta t^2 $   
> $dv_{k} = dv_{k-1}+dq_{k-1}*a_k*\Delta t$   
> $dq_k=dp_{k-1}*Exp({\omega_k}*\Delta t)$

**注： $\tilde a_k $ 表示第 $k$ 个加速度计的读数， $b_a^k$ 表示第 $k$ 个加速度计的bias，$\tilde w_k $ 表示第 $k$ 个陀螺仪的读数， $b_g^k$ 表示第 $k$ 个陀螺仪的bias，$dt_{k}$ 表示 $\Delta t_{ik}$ ，$dp_{k}$ 表示 $\Delta p_{ik}$ ，$dv_{k}$ 表示 $\Delta v_{ik}$ ，$dq_{k}$ 表示 $\Delta R_{ik}$ ，都表示相对于起始IMU的预积分量， $\Delta t$ 表示前后两个IMU之间的时间间隔。 $b_a^k$ 和 $b_g^k$ 在第一次积分时默认为0，并且在短时间内认为bias不变，即有 $b_a^k=b_a^{k-1}$ ， $b_g^k=b_g^{k-1}$ ，bias会在视觉IMU联合初始化的时候估计出来。**

![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-0db47f5788c1a6e021aa07b244d2bffe_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-ae2e2aa62941893c8b23dea6a72f93c1_1440w.jpg)  
### 5. 真实值和估计值之间，由于白噪声的存在，会有一定的误差，假设白噪声服从高斯分布，那么状态向量的估计值的协方差矩阵可以递推，即不确定度的递推，先分离出误差形式。  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-6302a40d01a1fee924a220c8971b1661_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-32e67271f2d75b78734f1f198ad6d802_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-9d44986a05762019a88fba361e1792b3_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-42cc443253e43b5050eedebfb391547e_1440w.jpg)  
### 6. 白噪声的高斯分布证明及协方差递推  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-0e39d19965064389be5433e061a1430e_1440w.png)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-d6530c645939976409c94d122590e677_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-8964e121cc5036d1236c56529fc62456_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-ef3fe25675a8739d048be1a9c9e27a95_1440w.jpg)  
由于 $\eta _k^{gd}$ 是服从零均值高斯分布的， $\delta \phi_{ij} $ 是 $\eta _k^{gd}$ 的线性组合，因此 $\delta \phi_{ij} $ 也是服从零均值高斯分布的， $\delta v_{ij}$ 是 $\eta _k^{ad}$ 和 $\delta \phi_{ik} $ 的线性组合，因此也是高斯的，同理 $\delta p_{ij}$ 也是高斯的。也就是说，

$\delta \phi_{ij} 、\delta v_{ij}、\delta p_{ij}$ 都是服从零均值的高斯分布，写成递推形式有：

![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-3b06e4585b49f250fee61317b4a95de8_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-421730ebf922069f0118f25b21034797_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-fe47bfab4cf298dc1d19d55b2d5a7857_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-09d654fd915063c42477e13889778370_1440w.jpg)  


状态量的协方差递推

  
  
$A_{j-1} = \begin{bmatrix}\Delta \tilde R_{jj-1} & 0 & 0 \\                            -\Delta \tilde R_{ij-1} [a]_x\Delta t & I &0\\                           -\frac{1}{2}\Delta \tilde R_{ij-1}[x]_x\Delta t^2 & \Delta t I &I \end{bmatrix}$ $B_{j-1}=\begin{bmatrix}J_{r}^{j-1}\Delta t & 0\\                                                   0  & \Delta \tilde R_{ij-1}\Delta t\\                                                   0   & \frac{1}{2}\Delta \tilde R_{ij-1}\Delta t^2 \end{bmatrix}$ 

![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-63bf5be1e7540a1df6aca29d3abf288f_1440w.jpg)  
### 7. 当状态向量的bias发生更新的时候，预积分项需要重新进行积分，通常bias的增量都非常小，直接采用一阶近似来进行更新，而不用重新计算整个预积分过程，此时Jacobian可以利用递推进行计算。  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-d5435690dab2bda1d727c25e4ffc5afb_1440w.jpg)  


bias的一阶线性展开

  
  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-121f001d9ba30b638491f21ec86cf741_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-e30a54f3c3b3d1d36d3961339649f884_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-adf3e2b50eb888c7beb7e7d4a3924e87_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-732400e3ff31e2785d97d1911912f0b4_1440w.jpg)  
$(dp/dbg)_k = (dp/dbg)_{k-1}+ (dv/dbg)_{k-1}*\Delta t -\frac{1}{2}*dq_{k-1}*[a_k]_x*(dq/dbg)_{k-1}*\Delta t^2$ 

$(dp/dba)_k = (dp/dba)_{k-1}+ (dv/dba)_{k-1}*\Delta t -\frac{1}{2}*dq_{k-1}*\Delta t^2$ 

$(dv/dbg)_k = (dv/dbg)_{k-1}-dq_{k-1}*[a_k]_x*(dq/dbg)_{k-1}*\Delta t $ 

$(dv/dba)_k = (dv/dba)_{k-1}-(dq/dba)_{k-1}*\Delta t$ 

$(dq/dbg)_k = \tilde R_{k-1k}^T*(dq/dbg)_{k-1}-J_r^{k-1}*\Delta t$ 

前面四个递推公式可以由上式直接推导，最后一项推导如下：

$\begin{aligned}\frac{\partial \Delta \bar R_{ij}}{\partial  b^{g}}&=-\sum_{k=i}^{j-1}[\Delta \tilde R_{k+1j}(\bar{b_i})^TJ_r^k\Delta t]\\ &=-\sum_{k=i}^{j-2}[(\Delta \tilde R_{k+1j-1}(\bar{b_i})*\Delta \tilde R_{j-1j})^TJ_r^k\Delta t] - \Delta \tilde R_{jj}(\bar{b_i})^TJ_r^{j-1}\Delta t\\ &=-\sum_{k=i}^{j-2}[(\Delta \tilde R_{j-1j})^T * \Delta \tilde R_{k+1j-1}(\bar{b_i})^TJ_r^k\Delta t] -J_r^{j-1}\Delta t\\ &= (\Delta \tilde R_{j-1j})^T *-\sum_{k=i}^{j-2}[ \Delta \tilde R_{k+1j-1}(\bar{b_i})^TJ_r^k\Delta t] -J_r^{j-1}\Delta t\\ &=(\Delta \tilde R_{j-1j})^T *\frac{\partial \Delta \bar R_{ij-1}}{\partial  b^{g}} - J_r^{j-1}\Delta t \end{aligned}$ 

![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-330cfd5982938aaa610ad82c161ab7e2_1440w.jpg)  


预积分量对bias的jacobian

  
  
### 8. 完整积分过程  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-1016a07fd8a8fff17fec8dc897405ee0_1440w.jpg)  


增量式预积分迭代计算

  
  
### 9. 在和视觉或者其他传感器融合的时候，我们可以利用IMU的估计值，和其他传感器的真实值的差值来作为残差项，从而迭代的求解出最优解，此时估计量为以下形式，需要计算出每一个残差项对待求解变量的jacobian。  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-c8d9f160e316a8f91f669af35f51a2c3_1440w.jpg)  


和其他传感器融合时的残差项

  
  
定义每个变量的增量

![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-dfbe5c98050e08d4b8391e2da4dac6a3_1440w.jpg)  


“lift-solve-retract” method

  
  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-bd94f14686ec57212612fb23542950e0_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-2918a01ffb1053c732871811bb22f3a7_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-6b480d2032396e5f02c1a78cf7e6c74a_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-4eda6f0d6b48aec066864777840004ac_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-242b1b792b0e636198a305ba810f7deb_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-499dc4088b3bb3a901779a0a3ebd1f7c_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-2215b11429feb556f70114cee189d28a_1440w.jpg)  
![]((20231214)IMU预积分原理及代码实现_一条放浪不羁的爬虫/v2-419f99c82f07fcd87d3a2b9931a92593_1440w.jpg)  

```
if (jacobians) {
            if (jacobians[0]) {
                Eigen::Map<Eigen::Matrix<double, 15, 4, Eigen::RowMajor>> dr_dq_i(jacobians[0]);
                dr_dq_i.setZero();
                dr_dq_i.block<3, 3>(ES_Q, 0) = -right_jacobian(r.segment<3>(ES_Q)).inverse() * q_j.conjugate().matrix() * q_center_i.matrix();
                dr_dq_i.block<3, 3>(ES_P, 0) = imu_i.q_cs.conjugate().matrix() * hat(q_center_i.conjugate() * (p_j - p_center_i - dt * v_i - 0.5 * dt * dt * gravity));
                dr_dq_i.block<3, 3>(ES_V, 0) = imu_i.q_cs.conjugate().matrix() * hat(q_center_i.conjugate() * (v_j - v_i - dt * gravity));
                dr_dq_i = pre.delta.sqrt_inv_cov * dr_dq_i;
            }
            if (jacobians[1]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dp_i(jacobians[1]);
                dr_dp_i.setZero();
                dr_dp_i.block<3, 3>(ES_P, 0) = -q_i.conjugate().matrix();
                dr_dp_i = pre.delta.sqrt_inv_cov * dr_dp_i;
            }
            if (jacobians[2]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dv_i(jacobians[2]);
                dr_dv_i.setZero();
                dr_dv_i.block<3, 3>(ES_P, 0) = -dt * q_i.conjugate().matrix();
                dr_dv_i.block<3, 3>(ES_V, 0) = -q_i.conjugate().matrix();
                dr_dv_i = pre.delta.sqrt_inv_cov * dr_dv_i;
            }
            if (jacobians[3]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dbg_i(jacobians[3]);
                dr_dbg_i.setZero();
                dr_dbg_i.block<3, 3>(ES_Q, 0) = -right_jacobian(r.segment<3>(ES_Q)).inverse() * expmap(r.segment<3>(ES_Q)).conjugate().matrix() * right_jacobian(dq_dbg * dbg) * dq_dbg;
                dr_dbg_i.block<3, 3>(ES_P, 0) = -dp_dbg;
                dr_dbg_i.block<3, 3>(ES_V, 0) = -dv_dbg;
                dr_dbg_i.block<3, 3>(ES_BG, 0) = -Eigen::Matrix3d::Identity();
                dr_dbg_i = pre.delta.sqrt_inv_cov * dr_dbg_i;
            }
            if (jacobians[4]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dba_i(jacobians[4]);
                dr_dba_i.setZero();
                dr_dba_i.block<3, 3>(ES_P, 0) = -dp_dba;
                dr_dba_i.block<3, 3>(ES_V, 0) = -dv_dba;
                dr_dba_i.block<3, 3>(ES_BA, 0) = -Eigen::Matrix3d::Identity();
                dr_dba_i = pre.delta.sqrt_inv_cov * dr_dba_i;
            }
            if (jacobians[5]) {
                Eigen::Map<Eigen::Matrix<double, 15, 4, Eigen::RowMajor>> dr_dq_j(jacobians[5]);
                dr_dq_j.setZero();
                dr_dq_j.block<3, 3>(ES_Q, 0) = right_jacobian(r.segment<3>(ES_Q)).inverse() * imu_j.q_cs.conjugate().matrix();
                dr_dq_j.block<3, 3>(ES_P, 0) = -q_i.conjugate().matrix() * q_center_j.matrix() * hat(imu_j.p_cs);
                dr_dq_j = pre.delta.sqrt_inv_cov * dr_dq_j;
            }
            if (jacobians[6]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dp_j(jacobians[6]);
                dr_dp_j.setZero();
                dr_dp_j.block<3, 3>(ES_P, 0) = q_i.conjugate().matrix();
                dr_dp_j = pre.delta.sqrt_inv_cov * dr_dp_j;
            }
            if (jacobians[7]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dv_j(jacobians[7]);
                dr_dv_j.setZero();
                dr_dv_j.block<3, 3>(ES_V, 0) = q_i.conjugate().matrix();
                dr_dv_j = pre.delta.sqrt_inv_cov * dr_dv_j;
            }
            if (jacobians[8]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dbg_j(jacobians[8]);
                dr_dbg_j.setZero();
                dr_dbg_j.block<3, 3>(ES_BG, 0).setIdentity();
                dr_dbg_j = pre.delta.sqrt_inv_cov * dr_dbg_j;
            }
            if (jacobians[9]) {
                Eigen::Map<Eigen::Matrix<double, 15, 3, Eigen::RowMajor>> dr_dba_j(jacobians[9]);
                dr_dba_j.setZero();
                dr_dba_j.block<3, 3>(ES_BA, 0).setIdentity();
                dr_dba_j = pre.delta.sqrt_inv_cov * dr_dba_j;
            }
        }

```
### 参考文献  
1. Forster C, Carlone L, Dellaert F, et al. On-Manifold Preintegration for Real-Time Visual--Inertial Odometry[J]. IEEE Transactions on Robotics, 2016, 33(1): 1-21.
2. Li J, Yang B, Huang K, et al. Robust and Efficient Visual-Inertial Odometry with Multi-plane Priors[C]//Chinese Conference on Pattern Recognition and Computer Vision (PRCV). Springer, Cham, 2019: 283-295.
3. [https://github.com/itsuhane/slamtools](https://github.com/itsuhane/slamtools)
4. [https://github.com/zju3dv/PVIO](https://github.com/zju3dv/PVIO)

