# 视觉SLAM学习之李群李代数

 **Author:** [李阳]

 **Link:** [https://zhuanlan.zhihu.com/p/388778282]

2023/12/21 更新

[https://www.douban.com/group/topic/11115261/?\_i=31520601SSbwbX,31521081SSbwbX](https://www.douban.com/group/topic/11115261/?\_i=31520601SSbwbX,31521081SSbwbX)

这篇文章里面详细介绍了数学的体系结构，提到微分几何是流形上的分析——在拓扑空间上引入微分结构，里面分为古典微分几何和现代微分几何，古典的微分几何研究的是二维三维空间的几何量操作，但是并不能抽象更高维度的情况。更高维度更抽象的体系是引入流形（manifold）之后，通过代数的方法去隐式地描述发生在流形上面的变化，这样的好处我认为是赋予了非线性计算更直观的物理意义，而且我们可以从直观出发，根据所需要解决的问题来形成代数计算的规则。

我认为自己从读这篇文章收获很多，强烈建议阅读。

=====================更新结束

学习李群李代数的过程是首先看了高翔博士的《视觉SLAM十四讲》，十四讲是从旋转矩阵引出的李代数，通过 $3\times3$ 的旋转矩阵，推导出李代数是李群的局部性质的描述，是单位元 $\varepsilon$ 附近的正切空间。借助李群的理论，我们可以建立一个严格的微积分语料库去处理不确定性，微分计算和积分计算。

## 李群李代数的图形描述  
![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-7d02464f8076274ce5a7561d020ef24b_1440w.jpg)  


李群（蓝色）李代数（红色）直观描述

  
  
上图是两个概念的直观描述。需要注意的点如下：

1. 李群是一个连续光滑的群，它是一种流形（Manifold），图中蓝色的球体代表了该流形形成的球状空间。
2. 在单位元 $\varepsilon$ 处，有一个平面（ $T_\varepsilon \mathcal{M}$ ）正切于这个球体。
3. 指数映射：对于通过 $\varepsilon$ 的所有向量，例如 $\boldsymbol{v} t$ ，都可以通过指数映射到李群中的 $exp(\boldsymbol{v}t)$
4. 对数映射：对于李群上的任意元素，都可以通过对数映射到正切平面上的某一个向量，例如 $\chi_3$ -> $log(\chi_3)$ .

在机器人的状态估计中，我们把机器人的状态当做一个列向量，随着时间推移，这个向量向前迭代，体现在李群上就是该向量沿着流形表面不断演化。因为该表面是连续光滑的，所以，在任何一个位置上，都有且仅有一个正切平面，而这个正切平面，就是计算机可以运算的空间。李群中的特殊点：单位元处的正切空间代表了这个李群的李代数空间。

## 李群对向量的变换  
李群的一个重要性质是它能够对某些集合产生作用，改变这些集合里面的元素。例如，能够对2D或者3D空间内的向量施加旋转，平移，尺度缩放和组合的操作。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-739d7b528e6f3fb5ba0e0e917ccc5aef_1440w.jpg)  


2D/3D空间内常用的李群及其变换操作

  
  
上面的表格最需要关注的是最后两行，分别是SO(3)三维空间的旋转变换，SE(3)三维空间的刚体变换，SE(3)相比于SO(3)增加了平移部分。

## 正切空间和李代数  
由于在李群当中对物体运动的描述是通过矩阵，并且这个矩阵还具有自身的约束，计算机处理起来很不方便。所以我们引出了李代数的概念。为了更好的理解李代数的概念，我们需要从李群的那个流形上面做一个很好的过度，搞清楚为什么李代数和李群可以对应起来，到底他们之间的物理关联是什么。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-3dc91c2661b75510fddb2d2e3d911acb_1440w.jpg)  


李群的速度向量在正切空间内

  
  
给定在李群中的 $\chi(t)$，这个点随着时间在流形上移动，那么它的速度表达为 $\dot{\chi}=\frac{\partial \chi}{\partial t}$，这个向量所在的空间是正切空间（那个红色平面）。所以，我们定义出了李代数的概念：

向量 $\boldsymbol{m}$ ,维度和李群的自由度一致。例如，SO(3)的李群自由度是3，那么，对应的李代数的维度就是3；SE(3)的李群自由度是6（旋转3+平移3），那么李代数的维度就是6。

下面重点看一下SO(3)对应的李代数so(3)如何推导出来的。论文里面的推导过程和十四讲的4.1.2基本一致，不同的是 $RR^T=I$ 中两个 $R$ 的位置。

考虑任意一个旋转矩阵3X3的 $R$ ,它满足 $RR^T=I$ 。因为上面讲到正切空间需要在李群流形的某个点上面做导数，所以我们可以对这个等式两边求关于时间t的导数。

$\dot RR^T+R\dot R^T=0$ 对这个等式做一下调整，得到：

$\dot RR^T=-(\dot RR^T)^T$ 我们称 $\dot RR^T$ 为反对称矩阵(skew-symmetric matrix)。由于反对称矩阵只需要三个实数就可以唯一确定， $\boldsymbol \omega^\wedge=\begin{bmatrix}     0&-\omega_z&\omega_y     \\\omega_z&0&-\omega_x     \\-\omega_y&\omega_x&0 \end{bmatrix}$ ， $\dot RR^T=\boldsymbol \omega^\wedge\Rightarrow\dot R=\boldsymbol\omega^\wedge R$ 

可以看到，旋转矩阵的导数只需要将旋转矩阵本身左乘一个反对称矩阵。

当 $R=I$ 时， $\boldsymbol\omega^\wedge$ 位于SO(3)的李代数空间so(3), 因为反对称矩阵本身还是矩阵，但是完全可以通过分解的手段，在每一个基本矩阵前面添加系数来定义出这个反对称矩阵，所以，李代数就是三维向量的集合，每个向量对应一个反对称矩阵，这个反对称矩阵可以分解为三个分量，每个分量前面的系数是这个三维向量的分量：$\dot R=\boldsymbol\omega^\wedge=\omega_xE_x+\omega_yE_y+\omega_zE_z$ , $E_x=\begin{bmatrix}     0&0&0     \\0&0&-1     \\0&1&0 \end{bmatrix}$ , $E_y=\begin{bmatrix}     0&0&1     \\0&0&0     \\1&0&0 \end{bmatrix}$ , $E_z=\begin{bmatrix}     0&-1&0     \\1&0&0     \\0&0&0 \end{bmatrix}$ 

其中 $\omega_x,\omega_y,\omega_z$ 分别是三个矩阵对应的角速度。

从而，我们可以一一对应地映射一个三维向量 $\boldsymbol\omega=[\omega_x,\omega_y,\omega_z]^T$ ,这个向量可以产生一个反对称矩阵，用来描述R的导数性质。一般我们提到李代数，都是指一个向量。

## 指数映射  
$\dot R=\boldsymbol\omega^\wedge R$ 。在 $t_0$ 时刻，保持 $\boldsymbol\omega_0^\wedge $ 为常数，那么，这就是一个微分方程。当初始值 $R(t_0)=I$ 时，我们就可以得到：

$R(t)=exp(\boldsymbol\omega_0^\wedge t)$ 

到这里，我们可以利用指数的泰勒展开，对矩阵的指数展开其结果还是矩阵。这里我们先做一下处理，我们把 $\boldsymbol\omega=[\omega_x,\omega_y,\omega_z]^T$ 写成一个单位向量和模长的乘积，也就是

$\boldsymbol\omega t= \theta \boldsymbol u$ ,其中， $\boldsymbol u$ 是模长为1的单位向量， $\theta$ 是绕着这个旋转轴旋转的角度。

带入泰勒展开公式，并且利用反对称矩阵的性质，我们得到著名的罗德里格斯公式：

$R=exp(\theta \boldsymbol u^\wedge)=cos \theta I+sin\theta \boldsymbol u^\wedge +(1-cos\theta)  \boldsymbol u \boldsymbol u^T$ 这个表达形式是十四讲当中采用的，在论文中，对 $cos \theta I$ 这一项做了一下变化，

$R=cos \theta I+sin\theta \boldsymbol u^\wedge +(1-cos\theta)  \boldsymbol u \boldsymbol u^T =I +cos \theta I-I+sin\theta \boldsymbol u^\wedge +(1-cos\theta)  \boldsymbol u \boldsymbol u^T =I+sin\theta \boldsymbol u^\wedge+(1-cos\theta)(\boldsymbol u \boldsymbol u^T -I)$ 

因为 $ {\boldsymbol u^\wedge}^2=\boldsymbol u \boldsymbol u^T -I$ ,带入上面的最后一个等式，得到的结果是：

$R =I+sin\theta \boldsymbol u^\wedge+(1-cos\theta){\boldsymbol u^\wedge}^2$ 

## 对数映射  
这个过程是已知李群当中的三维旋转/三维变换矩阵，如何求那个向量的过程。这里采用的先求旋转角度：

$\theta=arccos\frac{tr(R)-1}{2}$ ，然后再根据旋转轴 $\boldsymbol u$ 被旋转矩阵作用之后不发生变化的特性，得到：

$R\boldsymbol u = \boldsymbol u$ 可以推导出，这个旋转矩阵特征值为1对应的特征向量，再单位化就是该旋转轴。从而，我们得到了对数映射的结果。下面的这张图总结了两种群和对应李代数之间的转换关系。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-7401528e16f06cb82d31b2668ed4211f_1440w.jpg)  


SO(3),SE(3)与so(3),se(3)的对应关系

  
  
## 李代数求导和扰动模型  
上图只是展示了李群-李代数之间的转换关系，但是并没有说明，如何针对一个李代数的函数，求该函数对李代数的导数。

这里有一个非常强烈的实际应用需求：在SLAM中，我们通常需要构建一个优化问题，该问题往往是通过图(Graph)的方式（之后会专门针对图优化写一篇g2o的文章）构建出一个目标函数，这个目标函数往往是重投影误差的最小二乘，这个函数是关于so(3)或者se(3)的函数，优化的变量就是流形上面的这个点。需要通过非线性优化迭代的方法去对相机的姿态或者是三维的地图点进行估计，每一次的迭代其实是更改李群中这个点的位置去最小化目标函数。根据非线性优化的基本思路，例如在LM方法中，我们需要知道每次迭代的雅克比矩阵，这个雅克比矩阵是关于李群的一个函数对李群的这个自变量的雅克比。相比于其他的非线性函数，该函数的自变量具有抽象、加法不封闭的特点，很难使用传统的方法求出函数对一个矩阵的偏导数。

所以，论文中研究了一个关于李群的函数 $f(\chi)$ 是如何对 $\chi$ 求右雅克比的。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-e5bc4874793e6264ed26a03e9efaf876_1440w.jpg)  


以李群为自变量的函数右雅克比矩阵变换关系

  
  
上图形象地展示了雅克比矩阵如何近似映射李代数中的向量。我们知道的是函数 $f(.)$ ->例如图像的重投影误差。我们想知道的是当在李群中添加一个微小的变化李代数对应 $\boldsymbol \tau_1=h\boldsymbol e_1,\boldsymbol \tau_2=h\boldsymbol e_2$ ,李群对应 $\tau_1，\tau_2$ ，经过函数变换如何通过雅克比矩阵线性化（当我们优化SE(3)时，其实李代数空间就是一个六维度的向量，会有六个方向 $\boldsymbol e_1,\cdots,\boldsymbol e_6$ ）。具体如下： 

1. **在 $\mathcal{M}$ 下， $\chi$ 经过函数 $f$ 映射到新的流形 $\mathcal{N}$**
2. **由于函数的非线性，微小扰动之后，通过 $f$ 映射到 $\mathcal{N}$ 空间就不在流形表面了。直观表达就是左侧图上的蓝色曲线(测地线)映射到右图那条蓝色曲线不会贴合在表面。**
3. **蓝色的曲线做投影在正切空间得到 $\boldsymbol \sigma_1(h),\boldsymbol \sigma_2(h)$ 曲线，雅克比矩阵的每一列其实是对应曲线的切线。从而，我们可以通过雅克比矩阵线性化地近地描述函数处理过后的李代数变化成了什么样子。**
4. **当我们把所有的基向量变换之后的切方向找到之后（也就是找到了雅克比矩阵），我们就可以得到总体的映射关系。**

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-9b00555a49178c26a81028c6c81f6944_1440w.jpg)  


右雅克比矩阵做映射的具体描述

  
  
上面的描述核心思想是：我们统一用向量（李代数）方式表示李群的状态，用一个 $\mathbb{R}^{n\times m}$ 的雅克比矩阵可以映射这个变化。

  


李代数求导，是根据求导的定义直接按照极限来推导的。-- 是李代数的微分模型 [半闲居士]([https://www.cnblogs.com/gaoxiang12/p/5577912.html](https://www.cnblogs.com/gaoxiang12/p/5577912.html))我们根据导数的定义去对李代数求导，会遇到需要不断求这个雅克比矩阵的需求，这在实际应用当中会严重影响计算的性能。再举一个非常接近实际的例子：

我们先复习一下高斯牛顿优化方法（GN）:

将一个非线性的函数在当前点做线性化： $f(x+\Delta x)  \approx f(x) + J(x)^T\Delta x$ 

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-68b74f42db564a13febd9c409c8b6f11_1440w.jpg)  
经过这次迭代，我们找到自变量 $\boldsymbol x$ 的增量 $\Delta\boldsymbol x$ .

但是，我们需要注意的点是：函数 $ f(\boldsymbol x + \Delta \boldsymbol x)$ 里面的加法在优化SO(3)上的旋转或者SE(3)上的转换是不成立的。

需要借助扰动，或者说是特殊的 $\oplus$ 符号代表在李群上增量（ $\mathcal{M}$ ）， $\ominus$ 在映射之后的空间（ $\mathcal{N}$ ）。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-16979b60cbb422baea1e6ac8abf40b85_1440w.jpg)  


SO(3)右扰动模型推导

  
  
## SLAM中的应用  
论文配套公开了`manif` ([https://github.com/artivis/manif](https://github.com/artivis/manif))的源代码，我选择了其中的`se3_sam`作为例子，分析一下李群李代数在机器人的状态估计当中的应用。可以结合论文当中的`V. LANDMARK-BASED LOCALIZATION AND MAPPING`章节一起看。


```
//源文件在
examples/se3_sam.cpp

```
这个例子是基于图优化构建顶点(Vertex)和边(Edge)来求解机器人的运动估计的。给定一个机器人在设置有固定路标的环境当中运动，并且受到控制输入的作用，作用形式是机器人的线速度或者是角速度。Xi是机器人的SE(3)姿态，bi是路标点的三维坐标。


```
 *                  ------- b1
 *          b3    /         |
 *          |   /       b4  |
 *          | /       /    \|
 *          X0 ---- X1 ---- X2
 *          | \   /   \   /
 *          |   b0      b2
 *          *
```
上面是图优化的结构，测量量包括：

1. 机器人的里程计，也就是机器人从Xi运动到Xj的变换
2. 路标点bi在机器人坐标系下Xj的坐标
3. \* 可以看做是整个问题的坐标原点，从\*到X0有一个转换关系，也是已知的。
4. 由于机器人在运动过程中，在某一时刻下只能看到若干个路标点，所以我们提前规定好对应关系：

poses --- landmarks  
 x0 --- b0  
 x0 --- b1  
 x0 --- b3  
 x1 --- b0  
 x1 --- b2  
 x1 --- b4  
 x2 --- b1  
 x2 --- b2  
 x2 --- b4

机器人的控制输入：


```
u = (vx*dt, 0, 0, 0, 0, w*dt)//x方向的线速度，绕z轴转动的角速度
```
  


机器人的状态使用SE(3)的齐次矩阵表达：


```
 X_i = |  R_i   t_i |        // position and orientation
       |   0     1  |
```
当机器人接受到控制之后，


```
X_j = X_i * Exp(u) = X_i + u
```
  


路标采用世界坐标系的 $x,y,z$ 表达。


```
 b_k = (bx_k, by_k, bz_k)
```
根据机器人的真实位姿和3D路标点，可以计算出机器人传感器坐标系下的路标点坐标。


```
y = X_simu.inverse().act(b);          // landmark measurement, before adding noise

```
  


总结变量如下：


```
Xi  : robot pose at time i, SE(3)
u   : robot control, (v*dt; 0; 0; 0; 0; w*dt) in se(3)
Q   : control perturbation covariance
b   : landmark position, R^3
y   : Cartesian landmark measurement in robot frame, R^3
R   : covariance of the measurement noise

```
![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-52e1eb6b4f2f2d7f4f12f70ccca528f1_1440w.jpg)  


“加”（李群里面）“减”（李代数里面）操作与方向顺序

  
  
![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-fdbb1f1577d8390f75f7b28709f9c3d2_1440w.jpg)  


李群的伴随性质

  
  
论文特殊说明了，扰动添加在左侧和右侧，坐标系统具有不一样的性质，具体体现在右扰动是在 $T_\chi\mathcal{M}$ 上，是局部扰动, 是在 $T_\varepsilon\mathcal{M}$ 上，是全局的，所以上面对于 $\boldsymbol \tau$ 左上角的符号做了特殊说明，即：右扰动在部坐标系是 $\chi$ ，左扰动全局坐标系是 $\varepsilon$ 。习惯上，我们使用右扰动，也就是局部扰动。对于扰动的左右，也配套了左、右雅克比矩阵。左雅克比矩阵映射的是全局坐标系下的李代数，右雅克比矩阵映射的是局部的李代数。`manif`代码实现出来右雅克比矩阵。十四讲里面SO3的扰动模型是左扰动，所以我们可以看到两者得到的结果有微小的区别。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-368c752a78513d50762d63aa1f04abc3_1440w.jpg)  
在代码中，定义出来的residual是：

$residual=expectation\ominus measurement$ 

所以我们需要根据具体的计算场景区分到底这个 $measurement$ 是全局的：路标点的3D坐标（世界坐标系下）还是局部的：传感器里程计（机器人相邻两帧之间的转换关系）。如果是全局的，那么需要用 $left-\ominus$ ,如果是局部的，需要用 $right-\ominus$ 。

求解过程中使用到的变量：


```
// Declare some temporaries
    SE3Tangentd     d;              // motion expectation d = Xj (-) Xi = Xj.minus ( Xi )
    VectorY         e;              // measurement expectation e = h(X, b)
    MatrixT         J_d_xi, J_d_xj; // Jacobian of motion wrt poses i and j
    MatrixT         J_ix_x;         // Jacobian of inverse pose wrt pose
    MatrixYT        J_e_ix;         // Jacobian of measurement expectation wrt inverse pose
    MatrixYT        J_e_x;          // Jacobian of measurement expectation wrt pose
    MatrixYB        J_e_b;          // Jacobian of measurement expectation wrt lmk
    SE3Tangentd     dx;             // optimal pose correction step
    VectorB         db;             // optimal landmark correction step

    // Problem-size variables
    Matrix<double, NUM_STATES, 1>           dX; // optimal update step for all the SAM problem
    Matrix<double, NUM_MEAS, NUM_STATES>    J;  // full Jacobian
    Matrix<double, NUM_MEAS, 1>             r;  // full residual

```
![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-9d132b08b77f1945acaf9f1bfa107e06_1440w.jpg)  


向量函数-向量雅克比矩阵的排列规则

  
  
![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-182053f8919cdf696f6766584b010caa_1440w.jpg)  
## 算法运行步骤：  
1. 仿真器生成数据，生成的测量数据主要如下：


```
poses_simu     //仿真器生成的机器人受到u控制之后的状态真实值。第一个元素是*处的状态，单位矩阵
poses          //机器人受到u的控制（带噪声）之后的prior状态
controls       //带噪声的控制量输入
measurements   //带噪声的机器人对路标点的测量值
landmarks      //带噪声的路标点（世界坐标系）

```
  


### 生成误差向量和雅克比矩阵  
* 遍历机器人前后两个运动状态量，通过“右减”-- `rminus`得到相邻帧间的期望局部运动。


```
// expectation (use right-minus since motion measurements are local)
d  = Xj.rminus(Xi, J_d_xj, J_d_xi); // expected motion = Xj (-) Xi
```
* 通过 $expectation -  u$ 得到误差向量 $r$


```
r.segment<DoF>(row)         = W * (d - u).coeffs(); // residual
```
* 误差对second pose的雅克比矩阵


```
J.block<DoF, DoF>(row, col) = W * J_d_xj;
```
* 遍历机器人看到的每一个地图点，根据带噪声的世界坐标系下的地图点坐标 $landmarks[k]$ 和机器人的状态 $Xi = poses[i]$ ，得到机器人坐标系下的地图点局部坐标


```
e = Xi.inverse(J_ix_x).act(b, J_e_ix, J_e_b)
J_e_x   = J_e_ix * J_ix_x;
```
上面的推导做一下说明：`Xi`表示的是当前机器人的状态李代数，`ix`表示的是逆，在李群中，我们假设Xi对应的齐次矩阵是 $T_R$ , $P_W,P_R$ 分别表示地图点在世界坐标系和机器人坐标系的坐标，有： $P_W=b,T_RP_R=P_W=b$ ,所以， $P_R=T_R^{-1}b$ ,在上面的第一行代码中，除了求解出来了期望的地图点局部坐标，还求解出了机器人逆矩阵对矩阵的雅克比`J_ix_x`,期望坐标点对逆矩阵和地图点的雅克比`J_e_ix,J_e_b` ，从而根据雅克比的链式法则，得到期望坐标点关于机器人状态的雅克比矩阵`J_e_x`。


```
r.segment<Dim>(row)         = S * (e - y)
J.block<Dim, DoF>(row, col) = S * J_e_x;//3行6列


// Jacobian of residual wrt lmk
col = NUM_POSES * DoF + k * Dim;
J.block<Dim, Dim>(row, col) = S * J_e_b;//3行3列
```
上面的代码做一下说明：先求误差向量，`S`是地图点的信息矩阵：


```
S = y_sigmas.inverse()  .matrix().asDiagonal(); // this is R^(-T/2)
```
误差对机器人的雅克比就是期望对机器人的雅克比（不同的雅克比矩阵行数列数说明写在了代码后面）， 因为自由度是6，维度是3，所以误差对位姿的雅克比是3\*6，误差对坐标点的雅克比是3\*3。按照顺序，我们最终优化的是一个很长的列向量，这个列向量前面是三个6维度的机器人位姿，后面是五个3维度的地图点坐标。这里吐槽一个细节，`manif`里面代码实现层面求出来的雅克比矩阵其实是求了一下转置，所以它在后面的状态量增量的求解过程中公式是（109）所示的那样子。十四讲里面，雅克比矩阵没有被转置，所以高斯牛顿的表达式里面左乘的是雅克比矩阵的转置。注意这里的区别。

![]((20231221)视觉SLAM学习之李群李代数_李阳/v2-98159c74c53f8d4190a5456442236ce3_1440w.jpg)  

```
static constexpr int DoF = SE3d::DoF;//6
static constexpr int Dim = SE3d::Dim;//3
```
  


### 利用迭代求解  
当我们按照上面的步骤完成了雅克比矩阵的准备和误差向量的准备，就可以开始求解增量了。


```
dX = - (J.transpose() * J).inverse() * J.transpose() * r;

// update all poses
for (int i = 0; i < NUM_POSES; ++i)
{
    // we go very verbose here
    int dx_row          = i * DoF;
    constexpr int size  = DoF;
    dx                  = dX.segment<size>(dx_row);
    poses[i]            = poses[i] + dx;
}

   // update all landmarks
   for (int k = 0; k < NUM_LMKS; ++k)
   {
      // we go very verbose here
      int dx_row          = NUM_POSES * DoF + k * Dim;
      constexpr int size  = Dim;
      db                  = dX.segment<size>(dx_row);
      landmarks[k]        = landmarks[k] + db;
   }
```
  


### 运行  

```
❯ ./se3_sam

3D Smoothing and Mapping. 3 poses, 5 landmarks.
-----------------------------------------------
prior
pose  : +0.072 +0.077 +0.016 -0.073 +0.279 +0.104
pose  : +0.109 -0.015 +0.078 +0.172 +0.155 +0.135
pose  : +0.163 -0.035 +0.043 +0.132 +0.159 +0.019
lmk : +2.575 -0.784 -0.133
lmk : +1.608 -0.672 -1.487
lmk : +2.096 -0.647 +1.910
lmk : +2.142 +0.047 +1.031
lmk : +2.936 +0.838 -0.230
-----------------------------------------------
iterations
residual norm: 3.709e+03, step norm: 2.349e+00
residual norm: 6.128e+02, step norm: 9.758e-01
residual norm: 1.606e+02, step norm: 1.961e-01
residual norm: 6.563e+00, step norm: 1.109e-02
residual norm: 1.990e+00, step norm: 2.059e-05
residual norm: 1.990e+00, step norm: 2.918e-08
-----------------------------------------------
posterior
pose  : -0.000 -0.000 +0.000 -0.000 +0.000 +0.000
pose  : +0.101 +0.008 -0.001 -0.001 -0.000 +0.048
pose  : +0.201 +0.015 -0.003 -0.001 -0.001 +0.098
lmk : +2.999 -0.001 -0.001
lmk : +2.001 -1.000 -1.000
lmk : +1.997 -0.997 +1.000
lmk : +2.000 +0.999 +0.999
lmk : +2.004 +1.000 -1.001
-----------------------------------------------
ground truth
pose  : +0.000 +0.000 +0.000 +0.000 +0.000 +0.000
pose  : +0.100 +0.002 +0.000 +0.000 +0.000 +0.050
pose  : +0.200 +0.010 +0.000 +0.000 +0.000 +0.100
lmk : +3.000 +0.000 +0.000
lmk : +2.000 -1.000 -1.000
lmk : +2.000 -1.000 +1.000
lmk : +2.000 +1.000 +1.000
lmk : +2.000 +1.000 -1.000
-----------------------------------------------

```
  


## 参考  
[https://arxiv.org/abs/1812.01537](https://arxiv.org/abs/1812.01537)

《视觉SLAM十四讲》

[https://mp.weixin.qq.com/s?\_\_biz=MzI5MTM1MTQwMw==&mid=2247523304&idx=1&sn=81ed1b5bcb1eccf0f9169b8f2596db4e&chksm=ec1325ecdb64acfafb8689414d38ea7c4b79c7bdc92f3d1722f07a093c96d971d898caf3c3c7&mpshare=1&scene=1&srcid=0719qQh1si1iaNnN2L5SMm3i&sharer\_sharetime=1626701709907&sharer\_shareid=c269c349e4bed550ad46686d4affff90&exportkey=AahwVB88IlLvrDRciVQrqGs=&pass\_ticket=xaWSATo8DhSmc+IkV/LT8mAmYqoUH+mruhBc6U1RLZsJ7Mu04+7q/EOiSBqKNxAk&wx\_header=0#rd](https://mp.weixin.qq.com/s?\_\_biz=MzI5MTM1MTQwMw==&mid=2247523304&idx=1&sn=81ed1b5bcb1eccf0f9169b8f2596db4e&chksm=ec1325ecdb64acfafb8689414d38ea7c4b79c7bdc92f3d1722f07a093c96d971d898caf3c3c7&mpshare=1&scene=1&srcid=0719qQh1si1iaNnN2L5SMm3i&sharer\_sharetime=1626701709907&sharer\_shareid=c269c349e4bed550ad46686d4affff90&exportkey=AahwVB88IlLvrDRciVQrqGs=&pass\_ticket=xaWSATo8DhSmc+IkV/LT8mAmYqoUH+mruhBc6U1RLZsJ7Mu04+7q/EOiSBqKNxAk&wx\_header=0#rd)

